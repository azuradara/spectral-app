{"id":"../node_modules/merge-props/dist/index.js","dependencies":[{"name":"C:\\Users\\dara-\\Documents\\GitHub\\spectral-app\\node_modules\\merge-props\\dist\\index.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\dara-\\Documents\\GitHub\\spectral-app\\node_modules\\merge-props\\src\\index.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\dara-\\Documents\\GitHub\\spectral-app\\package.json","includedInParent":true,"mtime":1626033462762},{"name":"C:\\Users\\dara-\\Documents\\GitHub\\spectral-app\\node_modules\\merge-props\\package.json","includedInParent":true,"mtime":499162500000}],"generated":{"js":"\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction pushProp(target, key, value) {\n    if (key === 'className') {\n        target.className = [target.className, value].join(' ').trim();\n    }\n    else if (key === 'style') {\n        target.style = __assign({}, target.style, value);\n    }\n    else if (typeof value === 'function') {\n        var oldFn_1 = target[key];\n        target[key] = oldFn_1 ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            oldFn_1.apply(void 0, args);\n            value.apply(void 0, args);\n        } : value;\n    }\n    else if (\n    // skip merging undefined values\n    value === undefined ||\n        // skip if both value are the same primitive value\n        (typeof value !== 'object' && value === target[key])) {\n        return;\n    }\n    else if (!(key in target)) {\n        target[key] = value;\n    }\n    else {\n        throw new Error(\"Didn\\u2019t know how to merge prop '\" + key + \"'. \" +\n            \"Only 'className', 'style', and event handlers are supported\");\n    }\n}\n/**\n * Merges sets of props together:\n *  - duplicate `className` props get concatenated\n *  - duplicate `style` props get shallow merged (later props have precedence for conflicting rules)\n *  - duplicate functions (to be used for event handlers) get called in order from left to right\n * @param props Sets of props to merge together. Later props have precedence.\n */\nfunction mergeProps() {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    if (props.length === 1) {\n        return props[0];\n    }\n    return props.reduce(function (merged, ps) {\n        for (var key in ps) {\n            pushProp(merged, key, ps[key]);\n        }\n        return merged;\n    }, {});\n}\nexports.default = mergeProps;\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAEA,SAAS,QAAQ,CACf,MAA8B,EAC9B,GAAW,EACX,KAAU;IAEV,IAAI,GAAG,KAAK,WAAW,EAAE;QACvB,MAAM,CAAC,SAAS,GAAG,CAAC,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;KAC/D;SAAM,IAAI,GAAG,KAAK,OAAO,EAAE;QAC1B,MAAM,CAAC,KAAK,gBAAQ,MAAM,CAAC,KAAK,EAAK,KAAK,CAAE,CAAC;KAC9C;SAAM,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;QACtC,IAAM,OAAK,GAAG,MAAM,CAAC,GAAG,CAAyB,CAAC;QAClD,MAAM,CAAC,GAAG,CAAC,GAAG,OAAK,CAAC,CAAC,CAAC;YAAC,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YACnC,OAAK,eAAI,IAAI,EAAE;YACd,KAAkB,eAAI,IAAI,EAAE;QAC/B,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;KACX;SAAM;IACH,gCAAgC;IAChC,KAAK,KAAK,SAAS;QACnB,kDAAkD;QAClD,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,MAAM,CAAC,GAAG,CAAC,CAAC,EACpD;QACF,OAAM;KACP;SAAM,IAAI,CAAC,CAAC,GAAG,IAAI,MAAM,CAAC,EAAE;QAC3B,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;KACrB;SAAM;QACL,MAAM,IAAI,KAAK,CACb,yCAAkC,GAAG,QAAK;YAC1C,6DAA6D,CAC9D,CAAC;KACH;AACH,CAAC;AAED;;;;;;GAMG;AACH,SAAwB,UAAU;IAAiB,eAAW;SAAX,UAAW,EAAX,qBAAW,EAAX,IAAW;QAAX,0BAAW;;IAS5D,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QACtB,OAAO,KAAK,CAAC,CAAC,CAAQ,CAAC;KACxB;IAED,OAAO,KAAK,CAAC,MAAM,CAAC,UAAC,MAAM,EAAE,EAAO;QAClC,KAAK,IAAM,GAAG,IAAI,EAAE,EAAE;YACpB,QAAQ,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;SAChC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC,EAAE,EAAE,CAAQ,CAAC;AAChB,CAAC;AAnBD,6BAmBC","sourcesContent":["type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\nfunction pushProp(\n  target: { [key: string]: any },\n  key: string,\n  value: any\n): void {\n  if (key === 'className') {\n    target.className = [target.className, value].join(' ').trim();\n  } else if (key === 'style') {\n    target.style = { ...target.style, ...value };\n  } else if (typeof value === 'function') {\n    const oldFn = target[key] as Function | undefined;\n    target[key] = oldFn ? (...args: any[]) => {\n      oldFn(...args);\n      (value as Function)(...args);\n    } : value;\n  } else if (\n      // skip merging undefined values\n      value === undefined ||\n      // skip if both value are the same primitive value\n      (typeof value !== 'object' && value === target[key])\n    ) {\n    return\n  } else if (!(key in target)) {\n    target[key] = value;\n  } else {\n    throw new Error(\n      `Didnâ€™t know how to merge prop '${key}'. ` +\n      `Only 'className', 'style', and event handlers are supported`\n    );\n  }\n}\n\n/**\n * Merges sets of props together:\n *  - duplicate `className` props get concatenated\n *  - duplicate `style` props get shallow merged (later props have precedence for conflicting rules)\n *  - duplicate functions (to be used for event handlers) get called in order from left to right\n * @param props Sets of props to merge together. Later props have precedence.\n */\nexport default function mergeProps<T extends {}[]>(...props: T): {\n  [K in keyof UnionToIntersection<T[number]>]:\n      K extends 'className' ? string :\n      K extends 'style' ? UnionToIntersection<T[number]>[K] :\n      Exclude<\n        Extract<T[number], { [Q in K]: unknown }>[K],\n        undefined\n      >;\n} {\n  if (props.length === 1) {\n    return props[0] as any;\n  }\n\n  return props.reduce((merged, ps: any) => {\n    for (const key in ps) {\n      pushProp(merged, key, ps[key]);\n    }\n    return merged;\n  }, {}) as any;\n}\n"]}},"error":null,"hash":"967ec765a50347343c43467e75b44b7a","cacheData":{"env":{}}}